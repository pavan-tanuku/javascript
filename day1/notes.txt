Day - 1 Note's. 

let numberInt = 10;                         o/p: number
let numberFloat = 10.0;                     o/p: number
let string = 'oye';                         o/p: string
let char = 'A';                             o/p: string
let isTrue = true;                          o/p: boolean
const arr = ['abc', 1, '10.5', 9];          o/p: object
const obj = {                               o/p: object
    name: 'Hey',
    type: 'object'
};
let container;                              o/p: undefined
let hasValue = null;                        o/p: object
let greet = function () {                   o/p: function
    return "Hello!";
}

let notANumber = NaN;                       o/p: number
let symbol = Symbol('xyz');                 o/p: symbol


âš™ï¸ Concept: Hoisting in JavaScript.
When JavaScript code runs, the JS engine does two passes:
Memory creation phase â†’ where variables and functions are registered.
Execution phase â†’ where actual code runs.

During the memory phase:
Variables declared with var are hoisted and initialized as undefined.
Variables declared with let or const are hoisted too (yes!) but are placed in a 
Temporal Dead Zone (TDZ) â€” meaning they exist, but canâ€™t be used until the line of declaration is reached.


ğŸ§© Example 1 â€” Using var before declaration
console.log(a); 
var a = 10;
âœ… Output:
undefined
ğŸ‘‰ Why? Because var a was hoisted to the top and initialized with undefined before assignment.


ğŸ§© Example 2 â€” Using let before declaration
console.log(b); 
let b = 20;
âŒ Output:
ReferenceError: Cannot access 'b' before initialization
ğŸ‘‰ b is hoisted but is in the Temporal Dead Zone â€” JS protects it from being accessed before initialization.


ğŸ§© Example 3 â€” Using const before declaration
console.log(c);
const c = 30;
âŒ Output:
ReferenceError: Cannot access 'c' before initialization
ğŸ‘‰ Same reason as let, but const also must be initialized when declared.


ğŸ§© Snippet 3
var z = 100;
function test() {
  console.log(z);
  var z = 200;
  console.log(z);
}
test();

âŒ Your answer: 100 and 200
âœ… Actual Output:
undefined
200

ğŸ§  Why?
Inside the test() function, a new local variable z is declared with var z.
This shadows the global z.
That local z is hoisted to the top of the function and initialized with undefined.
So the steps are:
Local z hoisted â†’ undefined
console.log(z) â†’ prints undefined
z = 200
console.log(z) â†’ prints 200
ğŸ’¡ The global z = 100 is ignored inside the function because the local one takes precedence.